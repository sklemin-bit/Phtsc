<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Doc Cropper Classic</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { margin:0; height:100%; background:#111; color:#eee; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { display:flex; flex-direction:column; height:100%; }
    .top { padding:10px; background:#181818; display:flex; gap:8px; align-items:center; }
    .top input { flex:1; padding:10px; background:#222; color:#eee; border:1px solid #333; border-radius:10px; }
    .btn { padding:10px 14px; border-radius:10px; border:1px solid #444; background:#2b2b2b; color:#fff; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    #stage { flex:1; display:flex; align-items:center; justify-content:center; background:#000; position:relative; overflow:hidden; }
    canvas { max-width:100%; max-height:100%; background:#000; image-rendering: pixelated; image-rendering: -moz-crisp-edges; }
    .hint { padding:8px 10px; font-size:14px; color:#aaa; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <input id="imgUrl" placeholder="Ссылка подставится из ?img=... автоматически"/>
    <button id="send" class="btn" disabled>Отправить</button>
    <button id="undo" class="btn">Отменить точку</button>
    <button id="reset" class="btn">Сброс</button>
  </div>
  <div id="stage"><canvas id="cv"></canvas></div>
  <div class="hint">Кликни по четырём углам документа, затем — «Отправить».</div>
</div>

<script>
(function(){
  const tg = window.Telegram?.WebApp;
  if (tg) { try { tg.ready(); tg.expand(); } catch(e){} }

  const qs = new URLSearchParams(location.search);
  const rawImg = qs.get('img') || '';
  const input = document.getElementById('imgUrl');
  const btnSend = document.getElementById('send');
  const btnUndo = document.getElementById('undo');
  const btnReset = document.getElementById('reset');
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });
  const stage = document.getElementById('stage');

  function proxify(u) {
    if (!u) return u;
    return 'https://images.weserv.nl/?url=' + encodeURIComponent(u.replace(/^https?:\/\//,''));
  }

  const img = new Image();
  img.crossOrigin = "anonymous";
  let points = [];
  input.value = rawImg || '';

  img.onload = () => { fitAndDraw(); };
  img.onerror = () => { console.error('Image load error', input.value); alert('Не удалось загрузить картинку.'); };
  if (input.value) img.src = proxify(input.value);

  input.addEventListener('change', () => {
    points = [];
    if (input.value) img.src = proxify(input.value);
    else clearCanvas();
    updateButtons();
  });

  window.addEventListener('resize', fitAndDraw);

  function clearCanvas() {
    const pad = 10;
    const w = Math.max(10, stage.clientWidth - pad*2);
    const h = Math.max(10, stage.clientHeight - pad*2);
    cv.width = w; cv.height = h;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
  }

  function fitAndDraw() {
    if (!img.naturalWidth || !img.naturalHeight) { clearCanvas(); return; }
    const pad = 10;
    const maxW = Math.max(10, stage.clientWidth - pad*2);
    const maxH = Math.max(10, stage.clientHeight - pad*2);
    const k = Math.min(maxW / img.naturalWidth, maxH / img.naturalHeight);
    const w = Math.max(10, Math.floor(img.naturalWidth * k));
    const h = Math.max(10, Math.floor(img.naturalHeight * k));
    cv.width = w; cv.height = h;
    draw();
  }

  function draw() {
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,cv.width,cv.height);
    if (img.complete && img.naturalWidth) ctx.drawImage(img, 0, 0, cv.width, cv.height);

    if (points.length > 0) {
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,212,255,0.9)';
      ctx.fillStyle = '#00d4ff';
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.stroke();
      for (const p of points) { ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill(); }
    }
    updateButtons();
  }

  function canvasCoords(evt) {
    const r = cv.getBoundingClientRect();
    const sx = cv.width / r.width, sy = cv.height / r.height;
    return { x: (evt.clientX - r.left) * sx, y: (evt.clientY - r.top) * sy };
  }

  cv.addEventListener('click', (e) => {
    if (points.length >= 4) return;
    const p = canvasCoords(e);
    points.push({ x:p.x, y:p.y });
    draw();
  });

  btnUndo.addEventListener('click', () => { if (points.length) points.pop(); draw(); });
  btnReset.addEventListener('click', () => { points = []; draw(); });

  function updateButtons(){ btnSend.disabled = !(points.length === 4 && img.naturalWidth && img.naturalHeight); }

  btnSend.addEventListener('click', () => {
    if (points.length !== 4) return;
    const payload = {
      pts: points.map(p => [Number(p.x.toFixed(2)), Number(p.y.toFixed(2))]),
      canvas_w: cv.width, canvas_h: cv.height, cw: cv.width, ch: cv.height,
      img_w: img.naturalWidth || img.width, img_h: img.naturalHeight || img.height,
      iw: img.naturalWidth || img.width, ih: img.naturalHeight || img.height,
      ver: "classic", ts: Date.now()
    };
    try {
      if (window.Telegram?.WebApp) {
        window.Telegram.WebApp.sendData(JSON.stringify(payload));
        setTimeout(() => { try { window.Telegram.WebApp.close(); } catch(e){} }, 150);
      } else {
        alert("Откройте редактор через кнопку бота в Telegram.");
      }
    } catch (e) {
      console.error('sendData error', e);
    }
  });
})();
</script>
</body>
</html>
