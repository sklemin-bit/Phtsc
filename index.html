<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ScanBot — выбор углов</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  html,body{height:100%;margin:0;background:#000;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto}
  #wrap{height:100%;display:flex;flex-direction:column}
  #stage{flex:1;display:flex;align-items:center;justify-content:center;background:#000}
  canvas{max-width:100%;max-height:100%;touch-action:none;display:block}
  #bar{padding:12px;display:flex;gap:8px;border-top:1px solid #222;background:#111}
  button{padding:10px 14px;border:0;border-radius:10px;background:#2563eb;color:#fff;font-weight:600}
  .ghost{background:#333}
  .hint{margin-left:auto;opacity:.7;font-size:13px}
</style>
</head>
<body>
<div id="wrap">
  <div id="stage"><canvas id="c"></canvas></div>
  <div id="bar">
    <button id="reset" class="ghost">Сброс</button>
    <button id="send">✅ Отправить</button>
    <div class="hint">Кликните 4 угла: ↖ ↗ ↘ ↙</div>
  </div>
</div>

<script>
const tg = window.Telegram.WebApp; tg.expand();

const urlParams = new URLSearchParams(location.search);
const imgURL = urlParams.get("img"); // желательно передавать сюда ссылку на оригинал

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const pointsVis = [];     // точки в координатах canvas (для отрисовки)
const pointsSrc = [];     // точки в координатах исходного изображения (для отправки)

const img = new Image();
let fit = { x:0, y:0, w:0, h:0 };   // прямоугольник, в который вписано изображение на canvas
let scaleVis = 1;                    // множитель: пиксели CSS -> пиксели canvas
let dpr = window.devicePixelRatio || 1;

// подгон размера канваса под контейнер с учётом devicePixelRatio
function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  const cssW = Math.max(320, Math.floor(rect.width));
  const cssH = Math.max(320, Math.floor(rect.height));
  dpr = window.devicePixelRatio || 1;
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  scaleVis = dpr;
  layoutImage();
  draw();
}

// вычисляем, как вписать изображение в canvas (letterbox), считаем fit{x,y,w,h}
function layoutImage() {
  if (!img.naturalWidth || !img.naturalHeight) { fit = {x:0,y:0,w:0,h:0}; return; }
  const cw = canvas.width, ch = canvas.height;
  const ir = img.naturalWidth / img.naturalHeight;
  const cr = cw / ch;
  let w,h;
  if (ir > cr) { // ограничивает ширина
    w = cw; h = Math.round(cw / ir);
  } else { // ограничивает высота
    h = ch; w = Math.round(ch * ir);
  }
  const x = Math.round((cw - w) / 2);
  const y = Math.round((ch - h) / 2);
  fit = { x, y, w, h };
}

// рисуем изображение + точки
function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  if (fit.w>0 && fit.h>0) ctx.drawImage(img, fit.x, fit.y, fit.w, fit.h);

  // линии/точки
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = '#00ff88';
  ctx.fillStyle = '#00ff88';
  if (pointsVis.length) {
    ctx.beginPath();
    pointsVis.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
    if (pointsVis.length===4) ctx.closePath();
    ctx.stroke();
    ctx.font = `${14*dpr}px sans-serif`;
    pointsVis.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,5*dpr,0,Math.PI*2); ctx.fill();
      ctx.fillText(String(i+1), p.x+6*dpr, p.y-6*dpr);
    });
  }
}

// перевод из координат клика мыши (client) -> координаты canvas -> координаты изображения
function clientToCanvasAndImage(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  // координаты внутри CSS-пикселей:
  const xCss = clientX - rect.left;
  const yCss = clientY - rect.top;
  // переведём в пиксели canvas (учёт devicePixelRatio):
  const x = xCss * dpr;
  const y = yCss * dpr;

  // лежит ли клик внутри прямоугольника вписанного изображения?
  const inside = (x >= fit.x && x <= fit.x + fit.w && y >= fit.y && y <= fit.y + fit.h);

  // координаты источника (natural) вычисляем только если внутри:
  let sx = null, sy = null;
  if (inside) {
    const nx = (x - fit.x) / fit.w; // 0..1
    const ny = (y - fit.y) / fit.h; // 0..1
    sx = nx * img.naturalWidth;
    sy = ny * img.naturalHeight;
  }
  return { x, y, inside, sx, sy };
}

canvas.addEventListener('pointerdown', (e)=>{
  if (!img.naturalWidth || pointsVis.length>=4) return;
  const { x, y, inside, sx, sy } = clientToCanvasAndImage(e.clientX, e.clientY);
  if (!inside) return; // клики вне картинки игнорим (по чёрным полям)
  pointsVis.push({ x, y });
  pointsSrc.push([ Math.round(sx), Math.round(sy) ]);
  draw();
});

document.getElementById('reset').addEventListener('click', ()=>{
  pointsVis.length = 0; pointsSrc.length = 0; draw();
});

document.getElementById('send').addEventListener('click', ()=>{
  if (pointsSrc.length !== 4) { tg.showPopup({title:'Нужно 4 точки',message:'Кликните по всем углам документа в порядке ↖ ↗ ↘ ↙'}); return; }
  tg.sendData(JSON.stringify({ pts: pointsSrc }));
  tg.close();
});

window.addEventListener('resize', ()=>{ resizeCanvas(); });

// загрузка изображения
img.onload = ()=>{ layoutImage(); draw(); };
if (imgURL) img.src = imgURL;
resizeCanvas();
</script>
</body>
</html>
