# scbot.py ‚Äî ScanBot v4.0.3-stable
# ‚úÖ –¢–æ–ª—å–∫–æ –∫–Ω–æ–ø–∫–∞ –≤ –º–µ–Ω—é (reply keyboard), –±–µ–∑ –∏–Ω–ª–∞–π–Ω
# ‚úÖ –ü—Ä–µ–≤—å—é –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä: ?img= (Weserv proxy –¥–ª—è Telegram CDN)
# ‚úÖ –†—É—á–Ω–∞—è –æ–±—Ä–µ–∑–∫–∞: –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ canvas‚Üí–æ—Ä–∏–≥–∏–Ω–∞–ª + —Ñ–∏–∫—Å–∞—Ü–∏—è EXIF-–æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
# ‚ùó –§–∞–π–ª –¢–û–õ–¨–ö–û Python (–±–µ–∑ HTML)

import os
import re
import cv2
import json
import time
import numpy as np
import requests
from PIL import Image, ImageOps
from urllib.parse import quote, urlencode

from telegram import (
    Update, InputFile, WebAppInfo, KeyboardButton,
    ReplyKeyboardMarkup, ReplyKeyboardRemove, Message
)
from telegram.error import BadRequest
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    ContextTypes, filters
)
from telegram.request import HTTPXRequest

# =================== CONFIG ===================
TOKEN = os.getenv("SCANBOT_TOKEN") or "7545863960:AAGRHjbGkVSEKlPWkMI0kBYyajceLm164cg"
ADMIN_CHAT_ID = int(os.getenv("ADMIN_CHAT_ID", "181726741"))
WEBAPP_URL = os.getenv("WEBAPP_URL", "https://sklemin-bit.github.io/Phtsc/").strip()

IMG_DELIVERY = os.getenv("WEBAPP_IMG_METHOD", "TELEGRAM_CDN").upper()   # TELEGRAM_CDN | TELEGRAPH
IMG_PROXY    = os.getenv("WEBAPP_IMG_PROXY", "WESERV").upper()          # WESERV | NONE

TG_BOTAPI_URL = os.getenv("TG_BOTAPI_URL", "https://api.telegram.org").strip()
TG_PROXY_URL  = os.getenv("TG_PROXY_URL", "").strip()

TMP = "tmp_scanbot_v4_0_3"
os.makedirs(TMP, exist_ok=True)

MAX_IMAGE_SIDE = 2500
MAX_TELEGRAM_SIZE = 9_500_000
TELEGRAPH_MAX_BYTES = 4_800_000

# =================== –£–¢–ò–õ–ò–¢–´ ===================
def cleanup_tmp(max_age_sec=3600):
    now = time.time()
    for name in os.listdir(TMP):
        path = os.path.join(TMP, name)
        try:
            if os.path.isfile(path) and now - os.path.getmtime(path) > max_age_sec:
                os.remove(path)
        except Exception:
            pass

def reencode_baseline_jpeg(src_path: str,
                           out_path: str | None = None,
                           max_side: int = 2500,
                           quality: int = 85) -> str:
    out_path = out_path or (src_path.rsplit('.', 1)[0] + "_safe.jpg")
    with Image.open(src_path) as im:
        im = ImageOps.exif_transpose(im).convert("RGB")
        w, h = im.size
        scale = min(1.0, max_side / max(w, h))
        if scale < 1.0:
            im = im.resize((int(w * scale), int(h * scale)), Image.LANCZOS)
        im.save(out_path, format="JPEG", quality=quality, optimize=True, progressive=False, subsampling="4:2:0")
    return out_path

def ensure_under_size(path: str, target_bytes: int, min_quality: int = 60, min_side: int = 640) -> str:
    if os.path.getsize(path) <= target_bytes:
        return path
    quality = 85
    side = 2000
    tmp = path
    for _ in range(7):
        quality = max(min_quality, quality - 6)
        side = max(min_side, int(side * 0.85))
        tmp = reencode_baseline_jpeg(path, out_path=path, max_side=side, quality=quality)
        if os.path.getsize(tmp) <= target_bytes:
            return tmp
    return tmp

def save_jpg(img, path, q=95):
    cv2.imwrite(path, img, [int(cv2.IMWRITE_JPEG_QUALITY), q])
    if os.path.getsize(path) > MAX_TELEGRAM_SIZE:
        ensure_under_size(path, MAX_TELEGRAM_SIZE)

def pil_preview_jpeg(src_path: str, max_side: int = 1280, quality: int = 80) -> str | None:
    try:
        with Image.open(src_path) as im:
            im = ImageOps.exif_transpose(im).convert("RGB")
            w, h = im.size
            scale = min(1.0, max_side / max(w, h))
            if scale < 1.0:
                im = im.resize((int(w * scale), int(h * scale)), Image.LANCZOS)
            out_path = src_path.rsplit('.', 1)[0] + "_prev.jpg"
            im.save(out_path, format="JPEG", quality=quality, optimize=True, progressive=False)
        ensure_under_size(out_path, TELEGRAPH_MAX_BYTES, min_quality=60, min_side=640)
        return out_path
    except Exception as e:
        print("pil_preview_jpeg error:", e)
        return None

def upload_to_telegraph(img_path: str) -> str | None:
    url = "https://telegra.ph/upload"
    def _try(file_path: str) -> str | None:
        try:
            with open(file_path, "rb") as f:
                files = {"file": ("image.jpg", f, "image/jpeg")}
                r = requests.post(url, files=files, timeout=30)
            if r.ok:
                data = r.json()
                if isinstance(data, list) and data and "src" in data[0]:
                    return "https://telegra.ph" + data[0]["src"]
            print("telegraph fail:", r.status_code, r.text[:200])
            return None
        except Exception as e:
            print("telegraph error:", e)
            return None
    if os.path.getsize(img_path) <= TELEGRAPH_MAX_BYTES:
        out = _try(img_path)
        if out: return out
    prev = pil_preview_jpeg(img_path, max_side=1280, quality=80)
    if prev and os.path.getsize(prev) <= TELEGRAPH_MAX_BYTES:
        out = _try(prev)
        if out: return out
    for side, q in [(1100, 78), (900, 72), (720, 68)]:
        try_path = reencode_baseline_jpeg(img_path, out_path=prev or img_path, max_side=side, quality=q)
        ensure_under_size(try_path, TELEGRAPH_MAX_BYTES, min_quality=60, min_side=640)
        out = _try(try_path)
        if out: return out
    return None

# -------- Telegram CDN helpers --------
def build_telegram_file_url(file_path: str) -> str:
    if not file_path:
        return ""
    if file_path.startswith("http://") or file_path.startswith("https://"):
        return file_path
    return f"https://api.telegram.org/file/bot{TOKEN}/{file_path}"

def mask_token(url: str) -> str:
    return re.sub(r"(https://api\.telegram\.org/file/bot)[^/]+", r"\1<SECRET>", url or "")

async def get_cdn_url_from_file_id(context: ContextTypes.DEFAULT_TYPE, file_id: str) -> str | None:
    try:
        f = await context.bot.get_file(file_id)
        fp = getattr(f, "file_path", None)
        if not fp:
            return None
        return build_telegram_file_url(fp)
    except Exception as e:
        print("get_cdn_url_from_file_id error:", e)
        return None

# -------- CORS proxy wrapper --------
def wrap_with_proxy(raw_url: str) -> str:
    if not raw_url or IMG_PROXY == "NONE":
        return raw_url
    no_scheme = raw_url.replace("https://", "").replace("http://", "")
    return f"https://images.weserv.nl/?{urlencode({'url': no_scheme, 'output': 'jpg', 'w': '1600', 'h': '1600', 'fit': 'inside', 'q': '85', 'cb': str(int(time.time()*1000))})}"

# -------- build editor URL (query ?img=...) --------
def build_editor_url(public_url: str | None) -> str:
    if not WEBAPP_URL:
        return ""
    if public_url:
        proxied = wrap_with_proxy(public_url)
        return f"{WEBAPP_URL}?img={quote(proxied, safe=':/?&=')}"
    return WEBAPP_URL

# ===== –¢–û–õ–¨–ö–û –ú–ï–ù–Æ (reply-keyboard) =====
def make_reply_editor_keyboard(public_url: str | None) -> ReplyKeyboardMarkup | None:
    url = build_editor_url(public_url)
    if not url:
        return None
    return ReplyKeyboardMarkup(
        [[KeyboardButton(text="üñ±Ô∏è –û—Ç–∫—Ä—ã—Ç—å —Ä–µ–¥–∞–∫—Ç–æ—Ä —Ç–æ—á–µ–∫", web_app=WebAppInfo(url=url))]],
        resize_keyboard=True, one_time_keyboard=False
    )

async def ensure_menu(context: ContextTypes.DEFAULT_TYPE, chat_id: int, public_url: str | None):
    kb = make_reply_editor_keyboard(public_url)
    if kb:
        await context.bot.send_message(chat_id, "–ú–µ–Ω—é –æ—Ç–∫—Ä—ã—Ç–æ: –∫–Ω–æ–ø–∫–∞ –Ω–∏–∂–µ ‚¨áÔ∏è", reply_markup=kb)

# =================== –ó–ê–ì–†–£–ó–ö–ê –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô –° –£–ß–Å–¢–û–ú EXIF ===================
def read_image_bgr_oriented(path: str):
    try:
        with Image.open(path) as im:
            im = ImageOps.exif_transpose(im).convert("RGB")
            arr = np.array(im)
        return cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
    except Exception as e:
        print("read_image_bgr_oriented error:", e)
        return cv2.imread(path)  # –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–Ω—Å (–±–µ–∑ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏)

# =================== –°–ö–ê–ù ===================
def enhance_scan(img):
    if img is None:
        raise ValueError("Empty image passed to enhance_scan")
    if img.ndim == 2:
        img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (0, 0), 3)
    div = cv2.divide(gray, blur, scale=255)
    norm = cv2.normalize(div, None, 0, 255, cv2.NORM_MINMAX)
    sharp = cv2.addWeighted(norm, 1.4, cv2.GaussianBlur(norm, (0, 0), 1.0), -0.4, 0)
    bw = cv2.adaptiveThreshold(sharp.astype(np.uint8), 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 21, 7)
    bw = cv2.medianBlur(bw, 3)
    return cv2.cvtColor(bw, cv2.COLOR_GRAY2BGR)

# =================== –û–¢–ü–†–ê–í–ö–ê ===================
async def send_image_safe(context: ContextTypes.DEFAULT_TYPE, chat_id: int, path: str,
                          caption: str | None = None) -> Message:
    abspath = os.path.abspath(path)
    try:
        with open(abspath, "rb") as f:
            return await context.bot.send_photo(chat_id=chat_id, photo=InputFile(f, filename="scan.jpg"),
                                                caption=caption)
    except BadRequest as e:
        if "Image_process_failed" not in str(e):
            raise
    safe_path = reencode_baseline_jpeg(abspath, out_path=abspath, max_side=2500, quality=85)
    try:
        with open(safe_path, "rb") as f:
            return await context.bot.send_photo(chat_id=chat_id, photo=InputFile(f, filename="scan.jpg"),
                                                caption=caption)
    except BadRequest as e2:
        if "Image_process_failed" not in str(e2):
            raise
    with open(safe_path, "rb") as f:
        return await context.bot.send_document(chat_id=chat_id, document=InputFile(f, filename="scan.jpg"),
                                               caption=caption)

# =================== –ü–ê–†–°–ï–† –¢–û–ß–ï–ö ===================
def _to_float(x):
    try:
        return float(x)
    except:
        return None

def parse_points(payload: dict):
    if not isinstance(payload, dict):
        return None
    for key in ["pts", "points", "corners", "quad"]:
        if key in payload:
            data = payload[key]
            break
    else:
        return None

    pts = []
    if isinstance(data, list):
        if len(data) == 8 and all(isinstance(v, (int, float, str)) for v in data):
            it = iter(data)
            for x, y in zip(it, it):
                fx, fy = _to_float(x), _to_float(y)
                if fx is None or fy is None:
                    return None
                pts.append((fx, fy))
        else:
            for p in data:
                if isinstance(p, (list, tuple)) and len(p) == 2:
                    fx, fy = _to_float(p[0]), _to_float(p[1])
                    if fx is None or fy is None:
                        return None
                    pts.append((fx, fy))
                elif isinstance(p, dict) and "x" in p and "y" in p:
                    fx, fy = _to_float(p["x"]), _to_float(p["y"])
                    if fx is None or fy is None:
                        return None
                    pts.append((fx, fy))
                else:
                    return None
    elif isinstance(data, dict):
        for k in ["tl", "tr", "br", "bl"]:
            if k not in data or not isinstance(data[k], (list, tuple)) or len(data[k]) != 2:
                return None
            fx, fy = _to_float(data[k][0]), _to_float(data[k][1])
            if fx is None or fy is None:
                return None
            pts.append((fx, fy))
    else:
        return None

    if len(pts) != 4:
        return None
    return pts

# =================== –û–ë–†–ê–ë–û–¢–ö–ê web_app_data ===================
async def webapp_points_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.effective_message
    wad = getattr(msg, "web_app_data", None)
    if not wad or not wad.data:
        return

    chat_id = update.effective_chat.id
    print(f"[RX] web_app_data from chat {chat_id}: {len(wad.data)} bytes")

    try:
        payload = json.loads(wad.data)
    except Exception:
        await context.bot.send_message(chat_id, "–û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON –æ—Ç —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞.", reply_markup=ReplyKeyboardRemove())
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    pts_raw = parse_points(payload)
    if not pts_raw:
        await context.bot.send_message(chat_id, "–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞—à—ë–ª —Ç–æ—á–∫–∏. –û–∂–∏–¥–∞—é { pts: [[x,y],[x,y],[x,y],[x,y]] }")
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    # --- –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ canvas ‚Üí –æ—Ä–∏–≥–∏–Ω–∞–ª (—Å —Ñ–æ–ª–±—ç–∫–∞–º–∏) ---
    def _f(v):
        try: return float(v)
        except: return 0.0
    cw = _f(payload.get("canvas_w") or payload.get("cw") or 0)
    ch = _f(payload.get("canvas_h") or payload.get("ch") or 0)
    iw = _f(payload.get("img_w")    or payload.get("iw") or 0)
    ih = _f(payload.get("img_h")    or payload.get("ih") or 0)
    if cw <= 0 or ch <= 0:
        cw, ch = iw, ih
    if cw <= 0 or ch <= 0:
        maxx = max(p[0] for p in pts_raw)
        maxy = max(p[1] for p in pts_raw)
        cw = max(1.0, maxx)
        ch = max(1.0, maxy)

    await context.bot.send_message(chat_id, "üìå –ü–æ–ª—É—á–∏–ª —Ç–æ—á–∫–∏, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é‚Ä¶")

    orig = context.user_data.get("orig_image")
    if not orig or not os.path.exists(orig):
        await context.bot.send_message(chat_id, "–û—Ä–∏–≥–∏–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –æ—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –µ—â—ë —Ä–∞–∑.")
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    img = read_image_bgr_oriented(orig)  # ‚Üê —É—á–∏—Ç—ã–≤–∞–µ–º EXIF –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é
    if img is None:
        await context.bot.send_message(chat_id, "–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    H, W = img.shape[:2]
    sx = W / cw
    sy = H / ch
    scaled = np.array([(x * sx, y * sy) for (x, y) in pts_raw], dtype=np.float32)

    # —É–ø–æ—Ä—è–¥–æ—á–∏–º —É–≥–ª—ã
    rect = scaled
    s = rect.sum(axis=1)
    diff = np.diff(rect, axis=1)
    ordered = np.zeros((4, 2), dtype=np.float32)
    ordered[0] = rect[np.argmin(s)]    # tl
    ordered[2] = rect[np.argmax(s)]    # br
    ordered[1] = rect[np.argmin(diff)] # tr
    ordered[3] = rect[np.argmax(diff)] # bl

    (tl, tr, br, bl) = ordered
    widthA = np.linalg.norm(br - bl)
    widthB = np.linalg.norm(tr - tl)
    heightA = np.linalg.norm(tr - br)
    heightB = np.linalg.norm(tl - bl)
    maxW = max(10, int(max(widthA, widthB)))
    maxH = max(10, int(max(heightA, heightB)))

    dst = np.array([[0, 0], [maxW - 1, 0], [maxW - 1, maxH - 1], [0, maxH - 1]], dtype=np.float32)
    M = cv2.getPerspectiveTransform(ordered, dst)
    warped = cv2.warpPerspective(img, M, (maxW, maxH), flags=cv2.INTER_CUBIC)
    result = enhance_scan(warped)

    out_path = os.path.join(TMP, f"{chat_id}_manual.jpg")
    save_jpg(result, out_path, q=95)
    sent = await send_image_safe(context, chat_id, out_path)

    # –æ–±–Ω–æ–≤–∏–º –ø—Ä–µ–≤—å—é –¥–ª—è –º–µ–Ω—é
    public_url = context.user_data.get("public_url")
    if IMG_DELIVERY == "TELEGRAM_CDN":
        try:
            if getattr(sent, "photo", None) and len(sent.photo) > 0:
                file_id = sent.photo[-1].file_id
                public_url = await get_cdn_url_from_file_id(context, file_id)
            elif getattr(sent, "document", None):
                file_id = sent.document.file_id
                public_url = await get_cdn_url_from_file_id(context, file_id)
        except Exception as e:
            print("cdn url after manual error:", e)
    else:
        try:
            prev = pil_preview_jpeg(out_path, max_side=1280, quality=80)
            public_url = upload_to_telegraph(prev or out_path)
        except Exception as e:
            print("telegraph reupload after manual error:", e)

    context.user_data["public_url"] = public_url
    print("[webapp] WEBAPP_URL :", WEBAPP_URL)
    print("[webapp] public_url :", mask_token(public_url or ""))
    print(f"[webapp] scale sx={sx:.4f} sy={sy:.4f} | canvas=({cw:.1f},{ch:.1f}) orig=({W},{H})")

    await context.bot.send_message(chat_id, "–ì–æ—Ç–æ–≤–æ! –ï—Å–ª–∏ –Ω—É–∂–Ω–æ ‚Äî –æ—Ç–∫—Ä–æ–π —Ä–µ–¥–∞–∫—Ç–æ—Ä —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é –Ω–∏–∂–µ.")
    await ensure_menu(context, chat_id, public_url)

# =================== –û–°–ù–û–í–ù–´–ï –•–ï–ù–î–õ–ï–†–´ ===================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ç–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ ‚Äî —è —Å–¥–µ–ª–∞—é —á–∏—Ç–∞–µ–º—ã–π —Å–∫–∞–Ω.")
    await ensure_menu(context, update.effective_chat.id, context.user_data.get("public_url"))

async def editor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await ensure_menu(context, update.effective_chat.id, context.user_data.get("public_url"))
    await update.message.reply_text("–û—Ç–∫—Ä–æ–π —Ä–µ–¥–∞–∫—Ç–æ—Ä —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é –Ω–∏–∂–µ.")

async def photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cleanup_tmp()
    chat_id = update.effective_chat.id
    await update.message.reply_text("üìÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–æ—Ç–æ...")

    tgphoto = update.message.photo[-1]
    tgfile = await tgphoto.get_file()
    in_path = os.path.join(TMP, f"{chat_id}_orig.jpg")
    await tgfile.download_to_drive(in_path)

    public_url = None
    if IMG_DELIVERY == "TELEGRAM_CDN":
        try:
            fp = getattr(tgfile, "file_path", None)
            public_url = build_telegram_file_url(fp or "")
        except Exception as e:
            print("build cdn url for original error:", e)
    else:
        try:
            prev_path = pil_preview_jpeg(in_path, max_side=1280, quality=80)
            public_url = upload_to_telegraph(prev_path or in_path)
        except Exception as e:
            print("telegraph upload error:", e)

    img = read_image_bgr_oriented(in_path)  # ‚Üê —É—á–∏—Ç—ã–≤–∞–µ–º EXIF
    if img is None:
        await update.message.reply_text("–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
        await ensure_menu(context, chat_id, public_url)
        return

    h, w = img.shape[:2]
    scale = min(1.0, MAX_IMAGE_SIDE / max(h, w))
    if scale < 1.0:
        img = cv2.resize(img, (int(w * scale), int(h * scale)), interpolation=cv2.INTER_AREA)

    result = enhance_scan(img)
    out_path = os.path.join(TMP, f"{chat_id}_scan.jpg")
    save_jpg(result, out_path)

    context.user_data["orig_image"] = in_path
    context.user_data["public_url"] = public_url
    print("WEBAPP_URL :", WEBAPP_URL)
    print("public_url :", mask_token(public_url or ""))

    caption = "–ì–æ—Ç–æ–≤–æ! –î–ª—è —Ç–æ—á–Ω–æ–π –æ–±—Ä–µ–∑–∫–∏ –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é –Ω–∏–∂–µ –∏ –æ—Ç–º–µ—Ç—å —É–≥–ª—ã."
    await send_image_safe(context, chat_id, out_path, caption=caption)
    await ensure_menu(context, chat_id, public_url)

# ---- –ú–û–ù–ò–¢–û–† (–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞) ----
async def monitor_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.effective_message
    if msg and getattr(msg, "web_app_data", None) and getattr(msg.web_app_data, "data", None):
        print(f"[MON] caught web_app_data in monitor_all, bytes={len(msg.web_app_data.data)}")

# =================== –ó–ê–ü–£–°–ö ===================
def main():
    if not TOKEN:
        print("‚ùå –û—à–∏–±–∫–∞: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç SCANBOT_TOKEN –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
        return
    if not WEBAPP_URL.startswith("https://"):
        print("‚ö†Ô∏è WEBAPP_URL –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å https. –°–µ–π—á–∞—Å:", WEBAPP_URL)

    request = HTTPXRequest(
        http_version="1.1",
        read_timeout=40.0, write_timeout=40.0, connect_timeout=40.0, pool_timeout=40.0,
        proxy_url=TG_PROXY_URL or None
    )
    base_url = TG_BOTAPI_URL.rstrip("/")

    builder = (ApplicationBuilder()
               .token(TOKEN)
               .base_url(f"{base_url}/bot")
               .request(request))
    app = builder.build()

    # web_app_data ‚Äî –ø–µ—Ä–≤—ã–º
    app.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, webapp_points_handler), group=0)
    app.add_handler(MessageHandler(filters.ALL, monitor_all), group=1)

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("editor", editor))
    app.add_handler(MessageHandler(filters.PHOTO, photo_handler))

    print("üöÄ ScanBot v4.0.3-stable –∑–∞–ø—É—â–µ–Ω")
    print("WEBAPP_URL    :", WEBAPP_URL)
    print("IMG_DELIVERY  :", IMG_DELIVERY, " | IMG_PROXY:", IMG_PROXY)
    print("TG_BOTAPI_URL :", base_url)
    print("TG_PROXY_URL  :", "(set)" if TG_PROXY_URL else "(none)")
    app.run_polling()

if __name__ == "__main__":
    main()
