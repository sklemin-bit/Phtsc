# scbot.py — ScanBot v4.0.3-stable
# ✅ Только кнопка в меню (reply keyboard), без инлайн
# ✅ Превью в редактор: ?img= (Weserv proxy для Telegram CDN)
# ✅ Ручная обрезка: масштабирование canvas→оригинал + фиксация EXIF-ориентации
# ❗ Файл ТОЛЬКО Python (без HTML)

import os
import re
import cv2
import json
import time
import numpy as np
import requests
from PIL import Image, ImageOps
from urllib.parse import quote, urlencode

from telegram import (
    Update, InputFile, WebAppInfo, KeyboardButton,
    ReplyKeyboardMarkup, ReplyKeyboardRemove, Message
)
from telegram.error import BadRequest
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    ContextTypes, filters
)
from telegram.request import HTTPXRequest

# =================== CONFIG ===================
TOKEN = os.getenv("SCANBOT_TOKEN") or "7545863960:AAGRHjbGkVSEKlPWkMI0kBYyajceLm164cg"
ADMIN_CHAT_ID = int(os.getenv("ADMIN_CHAT_ID", "181726741"))
WEBAPP_URL = os.getenv("WEBAPP_URL", "https://sklemin-bit.github.io/Phtsc/").strip()

IMG_DELIVERY = os.getenv("WEBAPP_IMG_METHOD", "TELEGRAM_CDN").upper()   # TELEGRAM_CDN | TELEGRAPH
IMG_PROXY    = os.getenv("WEBAPP_IMG_PROXY", "WESERV").upper()          # WESERV | NONE

TG_BOTAPI_URL = os.getenv("TG_BOTAPI_URL", "https://api.telegram.org").strip()
TG_PROXY_URL  = os.getenv("TG_PROXY_URL", "").strip()

TMP = "tmp_scanbot_v4_0_3"
os.makedirs(TMP, exist_ok=True)

MAX_IMAGE_SIDE = 2500
MAX_TELEGRAM_SIZE = 9_500_000
TELEGRAPH_MAX_BYTES = 4_800_000

# =================== УТИЛИТЫ ===================
def cleanup_tmp(max_age_sec=3600):
    now = time.time()
    for name in os.listdir(TMP):
        path = os.path.join(TMP, name)
        try:
            if os.path.isfile(path) and now - os.path.getmtime(path) > max_age_sec:
                os.remove(path)
        except Exception:
            pass

def reencode_baseline_jpeg(src_path: str,
                           out_path: str | None = None,
                           max_side: int = 2500,
                           quality: int = 85) -> str:
    out_path = out_path or (src_path.rsplit('.', 1)[0] + "_safe.jpg")
    with Image.open(src_path) as im:
        im = ImageOps.exif_transpose(im).convert("RGB")
        w, h = im.size
        scale = min(1.0, max_side / max(w, h))
        if scale < 1.0:
            im = im.resize((int(w * scale), int(h * scale)), Image.LANCZOS)
        im.save(out_path, format="JPEG", quality=quality, optimize=True, progressive=False, subsampling="4:2:0")
    return out_path

def ensure_under_size(path: str, target_bytes: int, min_quality: int = 60, min_side: int = 640) -> str:
    if os.path.getsize(path) <= target_bytes:
        return path
    quality = 85
    side = 2000
    tmp = path
    for _ in range(7):
        quality = max(min_quality, quality - 6)
        side = max(min_side, int(side * 0.85))
        tmp = reencode_baseline_jpeg(path, out_path=path, max_side=side, quality=quality)
        if os.path.getsize(tmp) <= target_bytes:
            return tmp
    return tmp

def save_jpg(img, path, q=95):
    cv2.imwrite(path, img, [int(cv2.IMWRITE_JPEG_QUALITY), q])
    if os.path.getsize(path) > MAX_TELEGRAM_SIZE:
        ensure_under_size(path, MAX_TELEGRAM_SIZE)

def pil_preview_jpeg(src_path: str, max_side: int = 1280, quality: int = 80) -> str | None:
    try:
        with Image.open(src_path) as im:
            im = ImageOps.exif_transpose(im).convert("RGB")
            w, h = im.size
            scale = min(1.0, max_side / max(w, h))
            if scale < 1.0:
                im = im.resize((int(w * scale), int(h * scale)), Image.LANCZOS)
            out_path = src_path.rsplit('.', 1)[0] + "_prev.jpg"
            im.save(out_path, format="JPEG", quality=quality, optimize=True, progressive=False)
        ensure_under_size(out_path, TELEGRAPH_MAX_BYTES, min_quality=60, min_side=640)
        return out_path
    except Exception as e:
        print("pil_preview_jpeg error:", e)
        return None

def upload_to_telegraph(img_path: str) -> str | None:
    url = "https://telegra.ph/upload"
    def _try(file_path: str) -> str | None:
        try:
            with open(file_path, "rb") as f:
                files = {"file": ("image.jpg", f, "image/jpeg")}
                r = requests.post(url, files=files, timeout=30)
            if r.ok:
                data = r.json()
                if isinstance(data, list) and data and "src" in data[0]:
                    return "https://telegra.ph" + data[0]["src"]
            print("telegraph fail:", r.status_code, r.text[:200])
            return None
        except Exception as e:
            print("telegraph error:", e)
            return None
    if os.path.getsize(img_path) <= TELEGRAPH_MAX_BYTES:
        out = _try(img_path)
        if out: return out
    prev = pil_preview_jpeg(img_path, max_side=1280, quality=80)
    if prev and os.path.getsize(prev) <= TELEGRAPH_MAX_BYTES:
        out = _try(prev)
        if out: return out
    for side, q in [(1100, 78), (900, 72), (720, 68)]:
        try_path = reencode_baseline_jpeg(img_path, out_path=prev or img_path, max_side=side, quality=q)
        ensure_under_size(try_path, TELEGRAPH_MAX_BYTES, min_quality=60, min_side=640)
        out = _try(try_path)
        if out: return out
    return None

# -------- Telegram CDN helpers --------
def build_telegram_file_url(file_path: str) -> str:
    if not file_path:
        return ""
    if file_path.startswith("http://") or file_path.startswith("https://"):
        return file_path
    return f"https://api.telegram.org/file/bot{TOKEN}/{file_path}"

def mask_token(url: str) -> str:
    return re.sub(r"(https://api\.telegram\.org/file/bot)[^/]+", r"\1<SECRET>", url or "")

async def get_cdn_url_from_file_id(context: ContextTypes.DEFAULT_TYPE, file_id: str) -> str | None:
    try:
        f = await context.bot.get_file(file_id)
        fp = getattr(f, "file_path", None)
        if not fp:
            return None
        return build_telegram_file_url(fp)
    except Exception as e:
        print("get_cdn_url_from_file_id error:", e)
        return None

# -------- CORS proxy wrapper --------
def wrap_with_proxy(raw_url: str) -> str:
    if not raw_url or IMG_PROXY == "NONE":
        return raw_url
    no_scheme = raw_url.replace("https://", "").replace("http://", "")
    return f"https://images.weserv.nl/?{urlencode({'url': no_scheme, 'output': 'jpg', 'w': '1600', 'h': '1600', 'fit': 'inside', 'q': '85', 'cb': str(int(time.time()*1000))})}"

# -------- build editor URL (query ?img=...) --------
def build_editor_url(public_url: str | None) -> str:
    if not WEBAPP_URL:
        return ""
    if public_url:
        proxied = wrap_with_proxy(public_url)
        return f"{WEBAPP_URL}?img={quote(proxied, safe=':/?&=')}"
    return WEBAPP_URL

# ===== ТОЛЬКО МЕНЮ (reply-keyboard) =====
def make_reply_editor_keyboard(public_url: str | None) -> ReplyKeyboardMarkup | None:
    url = build_editor_url(public_url)
    if not url:
        return None
    return ReplyKeyboardMarkup(
        [[KeyboardButton(text="🖱️ Открыть редактор точек", web_app=WebAppInfo(url=url))]],
        resize_keyboard=True, one_time_keyboard=False
    )

async def ensure_menu(context: ContextTypes.DEFAULT_TYPE, chat_id: int, public_url: str | None):
    kb = make_reply_editor_keyboard(public_url)
    if kb:
        await context.bot.send_message(chat_id, "Меню открыто: кнопка ниже ⬇️", reply_markup=kb)

# =================== ЗАГРУЗКА ИЗОБРАЖЕНИЙ С УЧЁТОМ EXIF ===================
def read_image_bgr_oriented(path: str):
    try:
        with Image.open(path) as im:
            im = ImageOps.exif_transpose(im).convert("RGB")
            arr = np.array(im)
        return cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
    except Exception as e:
        print("read_image_bgr_oriented error:", e)
        return cv2.imread(path)  # последний шанс (без ориентации)

# =================== СКАН ===================
def enhance_scan(img):
    if img is None:
        raise ValueError("Empty image passed to enhance_scan")
    if img.ndim == 2:
        img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (0, 0), 3)
    div = cv2.divide(gray, blur, scale=255)
    norm = cv2.normalize(div, None, 0, 255, cv2.NORM_MINMAX)
    sharp = cv2.addWeighted(norm, 1.4, cv2.GaussianBlur(norm, (0, 0), 1.0), -0.4, 0)
    bw = cv2.adaptiveThreshold(sharp.astype(np.uint8), 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 21, 7)
    bw = cv2.medianBlur(bw, 3)
    return cv2.cvtColor(bw, cv2.COLOR_GRAY2BGR)

# =================== ОТПРАВКА ===================
async def send_image_safe(context: ContextTypes.DEFAULT_TYPE, chat_id: int, path: str,
                          caption: str | None = None) -> Message:
    abspath = os.path.abspath(path)
    try:
        with open(abspath, "rb") as f:
            return await context.bot.send_photo(chat_id=chat_id, photo=InputFile(f, filename="scan.jpg"),
                                                caption=caption)
    except BadRequest as e:
        if "Image_process_failed" not in str(e):
            raise
    safe_path = reencode_baseline_jpeg(abspath, out_path=abspath, max_side=2500, quality=85)
    try:
        with open(safe_path, "rb") as f:
            return await context.bot.send_photo(chat_id=chat_id, photo=InputFile(f, filename="scan.jpg"),
                                                caption=caption)
    except BadRequest as e2:
        if "Image_process_failed" not in str(e2):
            raise
    with open(safe_path, "rb") as f:
        return await context.bot.send_document(chat_id=chat_id, document=InputFile(f, filename="scan.jpg"),
                                               caption=caption)

# =================== ПАРСЕР ТОЧЕК ===================
def _to_float(x):
    try:
        return float(x)
    except:
        return None

def parse_points(payload: dict):
    if not isinstance(payload, dict):
        return None
    for key in ["pts", "points", "corners", "quad"]:
        if key in payload:
            data = payload[key]
            break
    else:
        return None

    pts = []
    if isinstance(data, list):
        if len(data) == 8 and all(isinstance(v, (int, float, str)) for v in data):
            it = iter(data)
            for x, y in zip(it, it):
                fx, fy = _to_float(x), _to_float(y)
                if fx is None or fy is None:
                    return None
                pts.append((fx, fy))
        else:
            for p in data:
                if isinstance(p, (list, tuple)) and len(p) == 2:
                    fx, fy = _to_float(p[0]), _to_float(p[1])
                    if fx is None or fy is None:
                        return None
                    pts.append((fx, fy))
                elif isinstance(p, dict) and "x" in p and "y" in p:
                    fx, fy = _to_float(p["x"]), _to_float(p["y"])
                    if fx is None or fy is None:
                        return None
                    pts.append((fx, fy))
                else:
                    return None
    elif isinstance(data, dict):
        for k in ["tl", "tr", "br", "bl"]:
            if k not in data or not isinstance(data[k], (list, tuple)) or len(data[k]) != 2:
                return None
            fx, fy = _to_float(data[k][0]), _to_float(data[k][1])
            if fx is None or fy is None:
                return None
            pts.append((fx, fy))
    else:
        return None

    if len(pts) != 4:
        return None
    return pts

# =================== ОБРАБОТКА web_app_data ===================
async def webapp_points_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.effective_message
    wad = getattr(msg, "web_app_data", None)
    if not wad or not wad.data:
        return

    chat_id = update.effective_chat.id
    print(f"[RX] web_app_data from chat {chat_id}: {len(wad.data)} bytes")

    try:
        payload = json.loads(wad.data)
    except Exception:
        await context.bot.send_message(chat_id, "Ошибка: некорректный JSON от редактора.", reply_markup=ReplyKeyboardRemove())
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    pts_raw = parse_points(payload)
    if not pts_raw:
        await context.bot.send_message(chat_id, "Ошибка: не нашёл точки. Ожидаю { pts: [[x,y],[x,y],[x,y],[x,y]] }")
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    # --- масштабирование canvas → оригинал (с фолбэками) ---
    def _f(v):
        try: return float(v)
        except: return 0.0
    cw = _f(payload.get("canvas_w") or payload.get("cw") or 0)
    ch = _f(payload.get("canvas_h") or payload.get("ch") or 0)
    iw = _f(payload.get("img_w")    or payload.get("iw") or 0)
    ih = _f(payload.get("img_h")    or payload.get("ih") or 0)
    if cw <= 0 or ch <= 0:
        cw, ch = iw, ih
    if cw <= 0 or ch <= 0:
        maxx = max(p[0] for p in pts_raw)
        maxy = max(p[1] for p in pts_raw)
        cw = max(1.0, maxx)
        ch = max(1.0, maxy)

    await context.bot.send_message(chat_id, "📌 Получил точки, обрабатываю…")

    orig = context.user_data.get("orig_image")
    if not orig or not os.path.exists(orig):
        await context.bot.send_message(chat_id, "Оригинал не найден — отправь фото ещё раз.")
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    img = read_image_bgr_oriented(orig)  # ← учитываем EXIF ориентацию
    if img is None:
        await context.bot.send_message(chat_id, "Ошибка: не удалось прочитать изображение.")
        await ensure_menu(context, chat_id, context.user_data.get("public_url"))
        return

    H, W = img.shape[:2]
    sx = W / cw
    sy = H / ch
    scaled = np.array([(x * sx, y * sy) for (x, y) in pts_raw], dtype=np.float32)

    # упорядочим углы
    rect = scaled
    s = rect.sum(axis=1)
    diff = np.diff(rect, axis=1)
    ordered = np.zeros((4, 2), dtype=np.float32)
    ordered[0] = rect[np.argmin(s)]    # tl
    ordered[2] = rect[np.argmax(s)]    # br
    ordered[1] = rect[np.argmin(diff)] # tr
    ordered[3] = rect[np.argmax(diff)] # bl

    (tl, tr, br, bl) = ordered
    widthA = np.linalg.norm(br - bl)
    widthB = np.linalg.norm(tr - tl)
    heightA = np.linalg.norm(tr - br)
    heightB = np.linalg.norm(tl - bl)
    maxW = max(10, int(max(widthA, widthB)))
    maxH = max(10, int(max(heightA, heightB)))

    dst = np.array([[0, 0], [maxW - 1, 0], [maxW - 1, maxH - 1], [0, maxH - 1]], dtype=np.float32)
    M = cv2.getPerspectiveTransform(ordered, dst)
    warped = cv2.warpPerspective(img, M, (maxW, maxH), flags=cv2.INTER_CUBIC)
    result = enhance_scan(warped)

    out_path = os.path.join(TMP, f"{chat_id}_manual.jpg")
    save_jpg(result, out_path, q=95)
    sent = await send_image_safe(context, chat_id, out_path)

    # обновим превью для меню
    public_url = context.user_data.get("public_url")
    if IMG_DELIVERY == "TELEGRAM_CDN":
        try:
            if getattr(sent, "photo", None) and len(sent.photo) > 0:
                file_id = sent.photo[-1].file_id
                public_url = await get_cdn_url_from_file_id(context, file_id)
            elif getattr(sent, "document", None):
                file_id = sent.document.file_id
                public_url = await get_cdn_url_from_file_id(context, file_id)
        except Exception as e:
            print("cdn url after manual error:", e)
    else:
        try:
            prev = pil_preview_jpeg(out_path, max_side=1280, quality=80)
            public_url = upload_to_telegraph(prev or out_path)
        except Exception as e:
            print("telegraph reupload after manual error:", e)

    context.user_data["public_url"] = public_url
    print("[webapp] WEBAPP_URL :", WEBAPP_URL)
    print("[webapp] public_url :", mask_token(public_url or ""))
    print(f"[webapp] scale sx={sx:.4f} sy={sy:.4f} | canvas=({cw:.1f},{ch:.1f}) orig=({W},{H})")

    await context.bot.send_message(chat_id, "Готово! Если нужно — открой редактор через кнопку в меню ниже.")
    await ensure_menu(context, chat_id, public_url)

# =================== ОСНОВНЫЕ ХЕНДЛЕРЫ ===================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("👋 Привет! Отправь фото документа — я сделаю читаемый скан.")
    await ensure_menu(context, update.effective_chat.id, context.user_data.get("public_url"))

async def editor(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await ensure_menu(context, update.effective_chat.id, context.user_data.get("public_url"))
    await update.message.reply_text("Открой редактор через кнопку в меню ниже.")

async def photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cleanup_tmp()
    chat_id = update.effective_chat.id
    await update.message.reply_text("📄 Обрабатываю фото...")

    tgphoto = update.message.photo[-1]
    tgfile = await tgphoto.get_file()
    in_path = os.path.join(TMP, f"{chat_id}_orig.jpg")
    await tgfile.download_to_drive(in_path)

    public_url = None
    if IMG_DELIVERY == "TELEGRAM_CDN":
        try:
            fp = getattr(tgfile, "file_path", None)
            public_url = build_telegram_file_url(fp or "")
        except Exception as e:
            print("build cdn url for original error:", e)
    else:
        try:
            prev_path = pil_preview_jpeg(in_path, max_side=1280, quality=80)
            public_url = upload_to_telegraph(prev_path or in_path)
        except Exception as e:
            print("telegraph upload error:", e)

    img = read_image_bgr_oriented(in_path)  # ← учитываем EXIF
    if img is None:
        await update.message.reply_text("Ошибка: не удалось загрузить изображение.")
        await ensure_menu(context, chat_id, public_url)
        return

    h, w = img.shape[:2]
    scale = min(1.0, MAX_IMAGE_SIDE / max(h, w))
    if scale < 1.0:
        img = cv2.resize(img, (int(w * scale), int(h * scale)), interpolation=cv2.INTER_AREA)

    result = enhance_scan(img)
    out_path = os.path.join(TMP, f"{chat_id}_scan.jpg")
    save_jpg(result, out_path)

    context.user_data["orig_image"] = in_path
    context.user_data["public_url"] = public_url
    print("WEBAPP_URL :", WEBAPP_URL)
    print("public_url :", mask_token(public_url or ""))

    caption = "Готово! Для точной обрезки нажми кнопку в меню ниже и отметь углы."
    await send_image_safe(context, chat_id, out_path, caption=caption)
    await ensure_menu(context, chat_id, public_url)

# ---- МОНИТОР (диагностика) ----
async def monitor_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.effective_message
    if msg and getattr(msg, "web_app_data", None) and getattr(msg.web_app_data, "data", None):
        print(f"[MON] caught web_app_data in monitor_all, bytes={len(msg.web_app_data.data)}")

# =================== ЗАПУСК ===================
def main():
    if not TOKEN:
        print("❌ Ошибка: отсутствует SCANBOT_TOKEN в переменных окружения.")
        return
    if not WEBAPP_URL.startswith("https://"):
        print("⚠️ WEBAPP_URL должен быть https. Сейчас:", WEBAPP_URL)

    request = HTTPXRequest(
        http_version="1.1",
        read_timeout=40.0, write_timeout=40.0, connect_timeout=40.0, pool_timeout=40.0,
        proxy_url=TG_PROXY_URL or None
    )
    base_url = TG_BOTAPI_URL.rstrip("/")

    builder = (ApplicationBuilder()
               .token(TOKEN)
               .base_url(f"{base_url}/bot")
               .request(request))
    app = builder.build()

    # web_app_data — первым
    app.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, webapp_points_handler), group=0)
    app.add_handler(MessageHandler(filters.ALL, monitor_all), group=1)

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("editor", editor))
    app.add_handler(MessageHandler(filters.PHOTO, photo_handler))

    print("🚀 ScanBot v4.0.3-stable запущен")
    print("WEBAPP_URL    :", WEBAPP_URL)
    print("IMG_DELIVERY  :", IMG_DELIVERY, " | IMG_PROXY:", IMG_PROXY)
    print("TG_BOTAPI_URL :", base_url)
    print("TG_PROXY_URL  :", "(set)" if TG_PROXY_URL else "(none)")
    app.run_polling()

if __name__ == "__main__":
    main()
