<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Doc Cropper Mini</title>
  <style>
    html, body {margin:0; height:100%; background:#111; color:#eee; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    .wrap {display:flex; flex-direction:column; height:100%;}
    .top {padding:10px; background:#181818; display:flex; gap:10px; align-items:center;}
    .top input {flex:1; padding:8px; background:#222; color:#eee; border:1px solid #333; border-radius:8px;}
    .btn {padding:10px 14px; border-radius:10px; border:1px solid #444; background:#2a2a2a; color:#fff; cursor:pointer;}
    .btn:disabled {opacity:.5; cursor:not-allowed;}
    #stage {flex:1; display:flex; align-items:center; justify-content:center; background:#000; position:relative;}
    canvas {max-width:100%; max-height:100%; background:#000;}
    .hint {padding:8px 10px; font-size:14px; color:#aaa;}
    .dot {position:absolute; width:10px; height:10px; background:#00d4ff; border-radius:50%; transform:translate(-50%, -50%);}
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <input id="imgUrl" placeholder="Ссылка на изображение (?img=... подставится автоматически)"/>
    <button id="send" class="btn" disabled>Отправить</button>
    <button id="reset" class="btn">Сброс</button>
  </div>
  <div id="stage">
    <canvas id="cv"></canvas>
  </div>
  <div class="hint">Кликни по четырём углам документа по часовой стрелке (или как получится) — отправим любые 4 точки.</div>
</div>

<script>
(function(){
  const tg = window.Telegram?.WebApp;
  if (tg) { tg.ready(); }

  const qs = new URLSearchParams(location.search);
  const raw = qs.get('img') || '';
  const input = document.getElementById('imgUrl');
  const btnSend = document.getElementById('send');
  const btnReset = document.getElementById('reset');
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const stage = document.getElementById('stage');

  function proxify(u) {
    if (!u) return u;
    return 'https://images.weserv.nl/?url=' + encodeURIComponent(u.replace(/^https?:\/\//,''));
  }

  input.value = raw || '';
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = draw;
  img.onerror = () => {
    console.error('Image load error', input.value);
    alert('Не удалось загрузить изображение. Проверь URL.');
  };
  if (input.value) img.src = proxify(input.value);

  let points = []; // [{x,y}, ...]

  function draw() {
    // впишем изображение в окно
    const pad = 10;
    const w = stage.clientWidth - pad*2;
    const h = stage.clientHeight - pad*2;
    const k = Math.min(w / img.width, h / img.height);
    cv.width = Math.max(10, Math.floor(img.width * k));
    cv.height = Math.max(10, Math.floor(img.height * k));
    ctx.clearRect(0,0,cv.width, cv.height);
    ctx.drawImage(img, 0, 0, cv.width, cv.height);

    // рисуем выбранные точки
    ctx.fillStyle = '#00d4ff';
    points.forEach(p => {
      ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
    });

    btnSend.disabled = points.length !== 4;
    updateDotsOverlay();
  }

  function addPoint(px, py) {
    if (points.length >= 4) return;
    points.push({x:px, y:py});
    draw();
  }

  cv.addEventListener('click', (e) => {
    const r = cv.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    addPoint(x, y);
  });

  btnReset.addEventListener('click', () => {
    points = [];
    draw();
  });

  btnSend.addEventListener('click', () => {
    if (points.length !== 4) return;
    const payload = { pts: points.map(p => [p.x, p.y]) };
    try {
      tg?.sendData(JSON.stringify(payload));
      // Telegram закроет WebApp автоматически, но на всякий:
      tg?.close();
    } catch (e) {
      console.error('sendData error', e);
      alert('sendData не сработал: ' + e);
    }
  });

  input.addEventListener('change', () => {
    points = [];
    img.src = proxify(input.value);
  });

  // Визуальные метки точек поверх canvas (необязательно, просто наглядно)
  function updateDotsOverlay(){
    [...document.querySelectorAll('.dot')].forEach(n => n.remove());
    points.forEach(p => {
      const d = document.createElement('div');
      d.className = 'dot';
      const rect = cv.getBoundingClientRect();
      const sx = rect.left + window.scrollX + p.x;
      const sy = rect.top + window.scrollY + p.y;
      d.style.left = sx + 'px';
      d.style.top  = sy + 'px';
      document.body.appendChild(d);
    });
  }

  window.addEventListener('resize', () => { draw(); });
})();
</script>
</body>
</html>
